
## PPC模型
`PPC 是 Process Per Connection 的缩写，又称做Apache模型，是通过多进程来实现业务并发。具体操作就是每次有新的连接，就去创建一个进程来处理这个连接的请求，这也是传统的UNIX服务器所采取的模型。`
## TPC
`TPC 是 Thread Per Connection 的缩写，是一种多线程并发处理模型。具体操作就是每次有新的连接就新建一个线程去专门处理这个连接的请求。与进程相比，线程要更轻量级，创建线程消耗的资源要少的多，而且线程间共用进程的存储空间，通信比较简单。因此，TPC实际上是弱化了PPC fork 代价高的问题和父子进程间通信复杂的问题。`
## Reactor模型
`
Reactor模式和Proactor模式在网络编程中经常会用到它们，是服务器端开发的常用设计模式，能提供高性能的I/O并发。
Reactor模式的底层往往使用select/poll/epoll等I/O复用方式来实现；Proactor模式的底层使用异步I/O（如Windows中的完成端口或UNIX中aio_*()系列函数）来实现。
`
- Reactor  
`
Reactor模式究竟是个什么东西呢？这要从事件驱动的开发方式说起。我们知道，对于应用服务器，一个主要规律就是，CPU的处理速度是要远远快于I/O速度的，如果CPU为了I/O操作（例如从Socket读取一段数据）而阻塞显然是不划算的。好一点的方法是分为多进程或者线程去进行处理，但是这样会带来一些进程切换的开销，试想一个进程一个数据读了500ms，期间进程切换到它3次，但是CPU却什么都不能干，就这么切换走了，是不是也不划算？
这时先驱们找到了事件驱动，或者叫回调的方式，来完成这件事情。这种方式就是，应用业务向一个中间人注册一个回调（event handler），当I/O就绪后，就这个中间人产生一个事件，并通知此handler进行处理。
好了，我们现在来看Reactor模式。在前面事件驱动的例子里有个问题：我们如何知道I/O就绪这个事件，谁来充当这个中间人？Reactor模式的答案是：由一个不断等待和循环的单独进程（线程）来做这件事，它接受所有handler的注册，并负责向操作系统查询I/O是否就绪，在就绪后就调用指定handler进行处理，这个角色的名字就叫做Reactor。
`  
参考：<http://aandds.com/blog/reactor-proactor.html>  

 
## Proactor模型
Proactor模式的底层使用异步I/O（如Windows中的完成端口或UNIX中aio_*()系列函数）来实现  

讲解比较直观的文章：<https://blog.csdn.net/libaineu2004/article/details/48931533>  


